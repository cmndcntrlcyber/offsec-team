import os
import json
import time
import logging
import subprocess
import requests
import re
from typing import Dict, List, Optional, Tuple, Union, Any
from pydantic import BaseModel, Field

class VulnerabilityScannerBridge:
    """
    A tool for integrating with and controlling vulnerability scanners.
    Provides capabilities to configure scanners, execute scans, and normalize results.
    """
    
    def __init__(self):
        self.supported_scanners = {
            "nuclei": {
                "description": "Fast and customizable vulnerability scanner",
                "config_schema": self._get_nuclei_config_schema(),
                "result_parser": self._parse_nuclei_results
            },
            "zap": {
                "description": "OWASP Zed Attack Proxy",
                "config_schema": self._get_zap_config_schema(),
                "result_parser": self._parse_zap_results
            },
            "burpsuite": {
                "description": "Burp Suite Professional",
                "config_schema": self._get_burpsuite_config_schema(),
                "result_parser": self._parse_burpsuite_results
            },
            "nmap": {
                "description": "Network mapper with NSE scripts",
                "config_schema": self._get_nmap_config_schema(),
                "result_parser": self._parse_nmap_results
            }
        }
        
        self.scan_history = {}
        
        # Setup logging
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        self.logger = logging.getLogger("VulnerabilityScannerBridge")
    
    def configure_scanner(self, scanner_type: str = Field(..., description="Type of scanner to configure"), 
                        scan_policy: Dict[str, Any] = Field(..., description="Scanner configuration and policy")) -> Dict[str, Any]:
        """
        Configure scanner settings and policies.
        
        Args:
            scanner_type: Type of scanner to configure (nuclei, zap, burpsuite, nmap)
            scan_policy: Scanner configuration and policy settings
                Common settings (specific options vary by scanner):
                - threads: Number of concurrent threads
                - timeout: Scan timeout in seconds
                - severity_filter: Minimum severity to report (low, medium, high, critical)
                - target_scope: Scope definition for the scan
                - scan_profile: Type of scan to perform (quick, full, custom)
            
        Returns:
            Dictionary containing the scanner configuration status
        """
        # Validate scanner type
        scanner_type = scanner_type.lower()
        if scanner_type not in self.supported_scanners:
            return {
                "success": False,
                "error": f"Unsupported scanner type '{scanner_type}'. Supported scanners: {', '.join(self.supported_scanners.keys())}"
            }
        
        # Get scanner configuration schema
        schema = self.supported_scanners[scanner_type]["config_schema"]
        
        # Validate scan policy against schema
        validation_result = self._validate_config(scan_policy, schema)
        if not validation_result["valid"]:
            return {
                "success": False,
                "error": f"Invalid scan policy: {validation_result['error']}",
                "schema": schema
            }
        
        # Generate configuration ID
        config_id = f"{scanner_type}-config-{int(time.time())}"
        
        # Store configuration
        self.scan_history[config_id] = {
            "type": "configuration",
            "scanner_type": scanner_type,
            "scan_policy": scan_policy,
            "timestamp": time.time()
        }
        
        # Log configuration
        self.logger.info(f"Configured {scanner_type} scanner with policy: {json.dumps(scan_policy, indent=2)}")
        
        return {
            "success": True,
            "config_id": config_id,
            "scanner_type": scanner_type,
            "message": f"Successfully configured {scanner_type} scanner"
        }
    
    def initiate_comprehensive_scan(self, target: str = Field(..., description="Target to scan"), 
                                  scan_type: str = Field(..., description="Type of scan"), 
                                  scan_options: Dict[str, Any] = Field(..., description="Scan options")) -> Dict[str, Any]:
        """
        Initiate a comprehensive scan using multiple scanners.
        
        Args:
            target: Target URL or host to scan
            scan_type: Type of scan (quick, comprehensive, custom)
            scan_options: Additional scan options
            
        Returns:
            Comprehensive scan results
        """
        try:
            # Configure and execute multiple scanners for comprehensive coverage
            scanners_to_use = ["nuclei", "nmap"]
            
            # Add web scanners if target is a URL
            if target.startswith("http"):
                scanners_to_use.append("zap")
            
            scan_results = {
                "target": target,
                "scan_type": scan_type,
                "scanner_results": {},
                "consolidated_vulnerabilities": [],
                "overall_success": True
            }
            
            for scanner in scanners_to_use:
                # Configure scanner
                config_result = self.configure_scanner(scanner, {
                    "severity_filter": "low",
                    "timeout": 300
                })
                
                if config_result["success"]:
                    # Execute scan
                    scan_result = self.execute_scan(target, {
                        "scanner_type": scanner,
                        "config_id": config_result["config_id"],
                        "async_scan": False
                    })
                    
                    scan_results["scanner_results"][scanner] = scan_result
                    
                    if scan_result["success"] and "results" in scan_result:
                        scan_results["consolidated_vulnerabilities"].extend(
                            scan_result["results"].get("vulnerabilities", [])
                        )
                else:
                    scan_results["scanner_results"][scanner] = config_result
                    scan_results["overall_success"] = False
            
            return {
                "success": scan_results["overall_success"],
                "scan_results": scan_results,
                "total_vulnerabilities": len(scan_results["consolidated_vulnerabilities"])
            }
            
        except Exception as e:
            self.logger.error(f"Failed comprehensive scan: {str(e)}")
            return {"success": False, "error": str(e)}
    
    def execute_scan(self, target_url: str = Field(..., description="URL of the target to scan"), 
                   scan_options: Dict[str, Any] = Field(..., description="Scan execution options")) -> Dict[str, Any]:
        """
        Launch scans against target applications.
        
        Args:
            target_url: URL of the target to scan
            scan_options: Scan execution options
                Required keys:
                - scanner_type: Type of scanner to use (nuclei, zap, burpsuite, nmap)
                - config_id: ID of the scanner configuration to use
                Optional keys:
                - scan_name: Name of the scan (default: auto-generated)
                - async_scan: Run scan asynchronously (default: False)
                - callback_url: URL to call when scan completes (for async scans)
            
        Returns:
            Dictionary containing the scan execution status and results (for sync scans)
        """
        # Validate scan options
        required_keys = ["scanner_type", "config_id"]
        for key in required_keys:
            if key not in scan_options:
                return {
                    "success": False,
                    "error": f"Missing required key '{key}' in scan options"
                }
        
        # Extract scan options
        scanner_type = scan_options["scanner_type"].lower()
        config_id = scan_options["config_id"]
        scan_name = scan_options.get("scan_name", f"Scan-{int(time.time())}")
        async_scan = scan_options.get("async_scan", False)
        callback_url = scan_options.get("callback_url", "")
        
        # Validate scanner type
        if scanner_type not in self.supported_scanners:
            return {
                "success": False,
                "error": f"Unsupported scanner type '{scanner_type}'. Supported scanners: {', '.join(self.supported_scanners.keys())}"
            }
        
        # Validate configuration ID
        if config_id not in self.scan_history or self.scan_history[config_id]["type"] != "configuration":
            return {
                "success": False,
                "error": f"Invalid configuration ID '{config_id}'"
            }
        
        # Validate configuration matches scanner type
        if self.scan_history[config_id]["scanner_type"] != scanner_type:
            return {
                "success": False,
                "error": f"Configuration ID '{config_id}' is for scanner type '{self.scan_history[config_id]['scanner_type']}', not '{scanner_type}'"
            }
        
        # Generate scan ID
        scan_id = f"{scanner_type}-scan-{int(time.time())}"
        
        # Store scan information
        self.scan_history[scan_id] = {
            "type": "scan",
            "scanner_type": scanner_type,
            "config_id": config_id,
            "target_url": target_url,
            "scan_name": scan_name,
            "status": "running",
            "start_time": time.time(),
            "end_time": None,
            "results": None
        }
        
        # Log scan execution
        self.logger.info(f"Executing {scanner_type} scan against {target_url}")
        
        try:
            # In a real implementation, we would execute the actual scanner
            # For this implementation, we'll simulate the scan execution
            if async_scan:
                # Start scan in background thread (simulated)
                self._simulate_async_scan(scan_id, scanner_type, target_url, self.scan_history[config_id]["scan_policy"], callback_url)
                
                return {
                    "success": True,
                    "scan_id": scan_id,
                    "status": "running",
                    "message": f"Started {scanner_type} scan against {target_url}",
                    "callback_url": callback_url
                }
            else:
                # Execute scan synchronously (simulated)
                scan_result = self._simulate_sync_scan(scan_id, scanner_type, target_url, self.scan_history[config_id]["scan_policy"])
                
                # Update scan history
                self.scan_history[scan_id]["status"] = "completed"
                self.scan_history[scan_id]["end_time"] = time.time()
                self.scan_history[scan_id]["results"] = scan_result
                
                return {
                    "success": True,
                    "scan_id": scan_id,
                    "status": "completed",
                    "message": f"Completed {scanner_type} scan against {target_url}",
                    "results": scan_result
                }
                
        except Exception as e:
            self.logger.error(f"Error executing {scanner_type} scan: {str(e)}")
            
            # Update scan history
            self.scan_history[scan_id]["status"] = "failed"
            self.scan_history[scan_id]["end_time"] = time.time()
            self.scan_history[scan_id]["error"] = str(e)
            
            return {
                "success": False,
                "scan_id": scan_id,
                "error": str(e)
            }
    
    def normalize_scan_results(self, results: Dict[str, Any] = Field(..., description="Scan results to normalize"), 
                             output_format: str = Field("standard", description="Output format")) -> Dict[str, Any]:
        """
        Standardize results from different scanners.
        
        Args:
            results: Scan results to normalize
                Required keys:
                - scanner_type: Type of scanner that generated the results
                - raw_results: Raw scan results
            output_format: Output format (standard, sarif, json, csv)
            
        Returns:
            Dictionary containing normalized scan results
        """
        # Validate results
        required_keys = ["scanner_type", "raw_results"]
        for key in required_keys:
            if key not in results:
                return {
                    "success": False,
                    "error": f"Missing required key '{key}' in results"
                }
        
        # Extract results
        scanner_type = results["scanner_type"].lower()
        raw_results = results["raw_results"]
        
        # Validate scanner type
        if scanner_type not in self.supported_scanners:
            return {
                "success": False,
                "error": f"Unsupported scanner type '{scanner_type}'. Supported scanners: {', '.join(self.supported_scanners.keys())}"
            }
        
        # Validate output format
        valid_formats = ["standard", "sarif", "json", "csv"]
        if output_format not in valid_formats:
            return {
                "success": False,
                "error": f"Invalid output format '{output_format}'. Supported formats: {', '.join(valid_formats)}"
            }
        
        try:
            # Parse results using scanner-specific parser
            parser = self.supported_scanners[scanner_type]["result_parser"]
            parsed_results = parser(raw_results)
            
            # Convert to requested output format
            if output_format == "standard":
                formatted_results = parsed_results
            elif output_format == "sarif":
                formatted_results = self._convert_to_sarif(parsed_results, scanner_type)
            elif output_format == "csv":
                formatted_results = self._convert_to_csv(parsed_results)
            else:  # json
                formatted_results = parsed_results
            
            return {
                "success": True,
                "normalized_results": formatted_results,
                "format": output_format,
                "vulnerability_count": len(parsed_results.get("vulnerabilities", [])),
                "severity_counts": self._count_by_severity(parsed_results)
            }
            
        except Exception as e:
            self.logger.error(f"Error normalizing {scanner_type} scan results: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def _validate_config(self, config: Dict[str, Any], schema: Dict[str, Any]) -> Dict[str, Any]:
        """Validate configuration against schema"""
        # Check required fields
        for field_name, field_schema in schema.items():
            if field_schema.get("required", False) and field_name not in config:
                return {
                    "valid": False,
                    "error": f"Missing required field '{field_name}'"
                }
        
        # Validate field types and values
        for field_name, field_value in config.items():
            if field_name not in schema:
                return {
                    "valid": False,
                    "error": f"Unknown field '{field_name}'"
                }
            
            field_schema = schema[field_name]
            field_type = field_schema.get("type", "string")
            
            # Type validation
            if field_type == "string" and not isinstance(field_value, str):
                return {
                    "valid": False,
                    "error": f"Field '{field_name}' must be a string"
                }
            elif field_type == "integer" and not isinstance(field_value, int):
                return {
                    "valid": False,
                    "error": f"Field '{field_name}' must be an integer"
                }
            elif field_type == "boolean" and not isinstance(field_value, bool):
                return {
                    "valid": False,
                    "error": f"Field '{field_name}' must be a boolean"
                }
            elif field_type == "array" and not isinstance(field_value, list):
                return {
                    "valid": False,
                    "error": f"Field '{field_name}' must be an array"
                }
            elif field_type == "object" and not isinstance(field_value, dict):
                return {
                    "valid": False,
                    "error": f"Field '{field_name}' must be an object"
                }
            
            # Enum validation
            if "enum" in field_schema and field_value not in field_schema["enum"]:
                return {
                    "valid": False,
                    "error": f"Field '{field_name}' must be one of: {', '.join(field_schema['enum'])}"
                }
            
            # Range validation
            if field_type == "integer":
                if "minimum" in field_schema and field_value < field_schema["minimum"]:
                    return {
                        "valid": False,
                        "error": f"Field '{field_name}' must be at least {field_schema['minimum']}"
                    }
                if "maximum" in field_schema and field_value > field_schema["maximum"]:
                    return {
                        "valid": False,
                        "error": f"Field '{field_name}' must be at most {field_schema['maximum']}"
                    }
        
        return {
            "valid": True
        }
    
    def _simulate_async_scan(self, scan_id: str, scanner_type: str, target_url: str, scan_policy: Dict[str, Any], callback_url: str) -> None:
        """Simulate asynchronous scan execution (for demonstration purposes)"""
        # In a real implementation, this would start the scan in a background thread
        # For this implementation, we'll just log the scan parameters
        self.logger.info(f"Started async {scanner_type} scan (ID: {scan_id}) against {target_url}")
        self.logger.info(f"Scan policy: {json.dumps(scan_policy, indent=2)}")
        self.logger.info(f"Callback URL: {callback_url}")
        
        # Simulate scan duration
        import threading
        def run_scan():
            # Simulate scan execution time
            time.sleep(5)
            
            # Simulate scan result
            scan_result = self._simulate_scan_result(scanner_type, target_url, scan_policy)
            
            # Update scan history
            self.scan_history[scan_id]["status"] = "completed"
            self.scan_history[scan_id]["end_time"] = time.time()
            self.scan_history[scan_id]["results"] = scan_result
            
            # Send callback (if provided)
            if callback_url:
                try:
                    requests.post(
                        callback_url,
                        json={
                            "scan_id": scan_id,
                            "status": "completed",
                            "message": f"Completed {scanner_type} scan against {target_url}",
                            "results": scan_result
                        }
                    )
                except Exception as e:
                    self.logger.error(f"Error sending callback: {str(e)}")
            
            self.logger.info(f"Completed async {scanner_type} scan (ID: {scan_id}) against {target_url}")
        
        # Start background thread
        thread = threading.Thread(target=run_scan)
        thread.daemon = True
        thread.start()
    
    def _simulate_sync_scan(self, scan_id: str, scanner_type: str, target_url: str, scan_policy: Dict[str, Any]) -> Dict[str, Any]:
        """Simulate synchronous scan execution (for demonstration purposes)"""
        # Log scan parameters
        self.logger.info(f"Executing sync {scanner_type} scan (ID: {scan_id}) against {target_url}")
        self.logger.info(f"Scan policy: {json.dumps(scan_policy, indent=2)}")
        
        # Simulate scan execution time
        scan_duration = 2  # seconds
        self.logger.info(f"Scanning target {target_url}...")
        time.sleep(scan_duration)
        
        # Simulate scan result
        scan_result = self._simulate_scan_result(scanner_type, target_url, scan_policy)
        
        self.logger.info(f"Completed sync {scanner_type} scan (ID: {scan_id}) against {target_url}")
        self.logger.info(f"Found {len(scan_result.get('vulnerabilities', []))} vulnerabilities")
        
        return scan_result
    
    def _simulate_scan_result(self, scanner_type: str, target_url: str, scan_policy: Dict[str, Any]) -> Dict[str, Any]:
        """Generate simulated scan results (for demonstration purposes)"""
        import random
        
        # Generate scan metadata
        scan_metadata = {
            "scanner": scanner_type,
            "target_url": target_url,
            "scan_policy": scan_policy,
            "scan_time": time.time(),
            "scan_duration": random.randint(1, 10)
        }
        
        # Generate vulnerabilities based on scanner type and scan policy
        vulnerabilities = []
        
        # Determine number of vulnerabilities to generate
        vuln_count = random.randint(0, 10)
        
        for i in range(vuln_count):
            # Generate vulnerability
            vulnerability = self._generate_simulated_vulnerability(scanner_type, target_url, i)
            vulnerabilities.append(vulnerability)
        
        # Filter vulnerabilities by severity (if specified in scan policy)
        if "severity_filter" in scan_policy:
            severity_levels = ["info", "low", "medium", "high", "critical"]
            min_severity_index = severity_levels.index(scan_policy["severity_filter"])
            vulnerabilities = [
                v for v in vulnerabilities 
                if severity_levels.index(v["severity"]) >= min_severity_index
            ]
        
        return {
            "metadata": scan_metadata,
            "vulnerabilities": vulnerabilities,
            "summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "severity_counts": self._count_by_severity({"vulnerabilities": vulnerabilities})
            }
        }
    
    def _generate_simulated_vulnerability(self, scanner_type: str, target_url: str, index: int) -> Dict[str, Any]:
        """Generate a simulated vulnerability (for demonstration purposes)"""
        import random
        
        # Common vulnerability types
        vuln_types = [
            {"name": "Cross-site Scripting (XSS)", "severity": "high", "cwe": "CWE-79"},
            {"name": "SQL Injection", "severity": "critical", "cwe": "CWE-89"},
            {"name": "Cross-site Request Forgery (CSRF)", "severity": "medium", "cwe": "CWE-352"},
            {"name": "Insecure Direct Object References", "severity": "high", "cwe": "CWE-639"},
            {"name": "Server-side Request Forgery (SSRF)", "severity": "high", "cwe": "CWE-918"},
            {"name": "XML External Entity (XXE)", "severity": "high", "cwe": "CWE-611"},
            {"name": "Open Redirect", "severity": "medium", "cwe": "CWE-601"},
            {"name": "Insecure Deserialization", "severity": "critical", "cwe": "CWE-502"},
            {"name": "Information Disclosure", "severity": "low", "cwe": "CWE-200"},
            {"name": "Missing Security Headers", "severity": "info", "cwe": "CWE-693"}
        ]
        
        # Select a random vulnerability type
        vuln_type = random.choice(vuln_types)
        
        # Generate vulnerability details
        vuln_id = f"{scanner_type}-{vuln_type['cwe']}-{index}"
        
        # Generate a URL path based on vulnerability type
        if vuln_type["name"] == "Cross-site Scripting (XSS)":
            path = random.choice(["/search", "/comments", "/profile"])
            param = random.choice(["q", "id", "name"])
        elif vuln_type["name"] == "SQL Injection":
            path = random.choice(["/products", "/users", "/articles"])
            param = random.choice(["id", "category", "user_id"])
        elif vuln_type["name"] == "Cross-site Request Forgery (CSRF)":
            path = random.choice(["/account/settings", "/user/profile", "/admin/config"])
            param = ""
        else:
            path = random.choice(["/api", "/data", "/admin", "/user", "/search"])
            param = random.choice(["id", "file", "query", "redirect", "token"])
        
        # Construct URL
        url = f"{target_url}{path}"
        if param:
            url += f"?{param}=value"
        
        return {
            "id": vuln_id,
            "type": vuln_type["name"],
            "severity": vuln_type["severity"],
            "cwe": vuln_type["cwe"],
            "url": url,
            "parameter": param,
            "description": f"Found {vuln_type['name']} vulnerability at {url}",
            "impact": f"This vulnerability could allow attackers to {self._get_impact_description(vuln_type['name'])}",
            "remediation": f"To remediate this issue, {self._get_remediation_description(vuln_type['name'])}",
            "evidence": self._generate_evidence(vuln_type["name"], url, param),
            "cvss_score": round(random.uniform(1.0, 10.0), 1)
        }
    
    def _get_impact_description(self, vuln_type: str) -> str:
        """Get impact description for a vulnerability type"""
        impact_descriptions = {
            "Cross-site Scripting (XSS)": "execute arbitrary JavaScript in the context of other users, potentially stealing cookies or performing actions on behalf of the victim",
            "SQL Injection": "execute arbitrary SQL commands on the database, potentially accessing, modifying, or deleting sensitive data",
            "Cross-site Request Forgery (CSRF)": "perform actions on behalf of authenticated users without their knowledge or consent",
            "Insecure Direct Object References": "access unauthorized data by manipulating parameters that reference objects directly",
            "Server-side Request Forgery (SSRF)": "make requests to internal resources that should not be accessible from the internet",
            "XML External Entity (XXE)": "read arbitrary files on the server or perform server-side request forgery",
            "Open Redirect": "redirect users to malicious websites, potentially facilitating phishing attacks",
            "Insecure Deserialization": "execute arbitrary code on the server by manipulating serialized objects",
            "Information Disclosure": "gain access to sensitive information that should not be exposed",
            "Missing Security Headers": "exploit various client-side vulnerabilities that could be prevented by proper security headers"
        }
        
        return impact_descriptions.get(vuln_type, "compromise the security of the application")
    
    def _get_remediation_description(self, vuln_type: str) -> str:
        """Get remediation description for a vulnerability type"""
        remediation_descriptions = {
            "Cross-site Scripting (XSS)": "implement proper input validation and output encoding for user-supplied data",
            "SQL Injection": "use parameterized queries or prepared statements instead of dynamic SQL",
            "Cross-site Request Forgery (CSRF)": "implement anti-CSRF tokens for all state-changing operations",
            "Insecure Direct Object References": "implement proper access controls and validate that the user has permission to access the requested object",
            "Server-side Request Forgery (SSRF)": "validate and sanitize user input before making requests, and use a whitelist of allowed domains",
            "XML External Entity (XXE)": "disable external entity processing in the XML parser",
            "Open Redirect": "validate and sanitize redirect URLs against a whitelist of allowed domains",
            "Insecure Deserialization": "avoid deserializing untrusted data, or use a serialization format that does not allow code execution",
            "Information Disclosure": "review and restrict the information exposed by the application",
            "Missing Security Headers": "configure the application to include appropriate security headers in responses"
        }
        
        return remediation_descriptions.get(vuln_type, "implement appropriate security controls based on the vulnerability type")
    
    def _generate_evidence(self, vuln_type: str, url: str, param: str) -> str:
        """Generate evidence for a vulnerability"""
        if vuln_type == "Cross-site Scripting (XSS)":
            return f"Request: GET {url}?{param}=<script>alert(1)</script>\nResponse: HTTP/1.1 200 OK\n...<script>alert(1)</script>..."
        elif vuln_type == "SQL Injection":
            return f"Request: GET {url}?{param}=1' OR '1'='1\nResponse: HTTP/1.1 200 OK\n...displaying all records..."
        elif vuln_type == "Cross-site Request Forgery (CSRF)":
            return f"The form at {url} does not contain an anti-CSRF token."
        elif vuln_type == "Server-side Request Forgery (SSRF)":
            return f"Request: GET {url}?{param}=http://internal-server\nResponse: HTTP/1.1 200 OK\n...internal server data..."
        else:
            return f"Details of the vulnerability at {url}"
    
    def _count_by_severity(self, results: Dict[str, Any]) -> Dict[str, int]:
        """Count vulnerabilities by severity"""
        vulnerabilities = results.get("vulnerabilities", [])
        severity_counts = {
            "critical": 0,
            "high": 0,
            "medium": 0,
            "low": 0,
            "info": 0
        }
        
        for vulnerability in vulnerabilities:
            severity = vulnerability.get("severity", "").lower()
            if severity in severity_counts:
                severity_counts[severity] += 1
        
        return severity_counts
    
    def _convert_to_sarif(self, results: Dict[str, Any], scanner_type: str) -> Dict[str, Any]:
        """Convert normalized results to SARIF format"""
        sarif = {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": [
                {
                    "tool": {
                        "driver": {
                            "name": scanner_type,
                            "informationUri": f"https://example.com/scanners/{scanner_type}",
                            "rules": []
                        }
                    },
                    "results": []
                }
            ]
        }
        
        # Rule definitions
        rule_indices = {}
        
        # Process vulnerabilities
        for vuln in results.get("vulnerabilities", []):
            vuln_type = vuln.get("type", "Unknown")
            cwe = vuln.get("cwe", "Unknown")
            
            # Create rule if it doesn't exist
            rule_id = cwe.replace("-", "")
            if rule_id not in rule_indices:
                rule = {
                    "id": rule_id,
                    "name": vuln_type,
                    "shortDescription": {
                        "text": vuln_type
                    },
                    "fullDescription": {
                        "text": vuln.get("description", "")
                    },
                    "helpUri": f"https://cwe.mitre.org/data/definitions/{rule_id.replace('CWE', '')}.html",
                    "defaultConfiguration": {
                        "level": self._convert_severity_to_sarif(vuln.get("severity", ""))
                    }
                }
                
                rule_indices[rule_id] = len(sarif["runs"][0]["tool"]["driver"]["rules"])
                sarif["runs"][0]["tool"]["driver"]["rules"].append(rule)
            
            # Create result
            result = {
                "ruleId": rule_id,
                "ruleIndex": rule_indices[rule_id],
                "level": self._convert_severity_to_sarif(vuln.get("severity", "")),
                "message": {
                    "text": vuln.get("description", "")
                },
                "locations": [
                    {
                        "physicalLocation": {
                            "artifactLocation": {
                                "uri": vuln.get("url", "")
                            }
                        }
                    }
                ]
            }
            
            sarif["runs"][0]["results"].append(result)
        
        return sarif
    
    def _convert_severity_to_sarif(self, severity: str) -> str:
        """Convert vulnerability severity to SARIF level"""
        severity_map = {
            "critical": "error",
            "high": "error",
            "medium": "warning",
            "low": "note",
            "info": "note"
        }
        
        return severity_map.get(severity.lower(), "warning")
    
    def _convert_to_csv(self, results: Dict[str, Any]) -> str:
        """Convert normalized results to CSV format"""
        vulnerabilities = results.get("vulnerabilities", [])
        
        if not vulnerabilities:
            return "No vulnerabilities found"
        
        # Define CSV headers based on first vulnerability
        headers = list(vulnerabilities[0].keys())
        
        # Generate CSV content
        csv_lines = [",".join([f'"{h}"' for h in headers])]
        
        for vuln in vulnerabilities:
            csv_line = []
            for header in headers:
                value = vuln.get(header, "")
                if isinstance(value, str):
                    # Escape quotes and wrap in quotes
                    escaped_value = value.replace('"', '""')
                    value = f'"{escaped_value}"'
                else:
                    value = str(value)
                csv_line.append(value)
            
            csv_lines.append(",".join(csv_line))
        
        return "\n".join(csv_lines)
    
    def _get_nuclei_config_schema(self) -> Dict[str, Any]:
        """Get configuration schema for Nuclei scanner"""
        return {
            "threads": {
                "type": "integer",
                "description": "Number of concurrent threads",
                "minimum": 1,
                "maximum": 100,
                "default": 10,
                "required": False
            },
            "timeout": {
                "type": "integer",
                "description": "Scan timeout in seconds",
                "minimum": 1,
                "default": 300,
                "required": False
            },
            "severity_filter": {
                "type": "string",
                "description": "Minimum severity to report",
                "enum": ["info", "low", "medium", "high", "critical"],
                "default": "low",
                "required": False
            },
            "templates": {
                "type": "array",
                "description": "List of template categories to use",
                "items": {
                    "type": "string"
                },
                "default": ["cves", "vulnerabilities", "misconfigurations"],
                "required": False
            },
            "rate_limit": {
                "type": "integer",
                "description": "Maximum number of requests per second",
                "minimum": 1,
                "default": 150,
                "required": False
            }
        }
    
    def _parse_nuclei_results(self, raw_results: Any) -> Dict[str, Any]:
        """Parse Nuclei scan results"""
        # In a real implementation, this would parse Nuclei's JSON output
        # For this implementation, we'll assume raw_results is already a dict
        if isinstance(raw_results, str):
            try:
                results = json.loads(raw_results)
            except json.JSONDecodeError:
                # Handle non-JSON format (e.g., CLI output)
                return {
                    "vulnerabilities": [],
                    "error": "Unable to parse Nuclei output as JSON"
                }
        else:
            results = raw_results
        
        # Convert to standard format
        vulnerabilities = []
        
        for item in results.get("results", []):
            vulnerability = {
                "id": item.get("template-id", "unknown"),
                "type": item.get("info", {}).get("name", "Unknown"),
                "severity": item.get("info", {}).get("severity", "unknown").lower(),
                "cwe": item.get("info", {}).get("classification", {}).get("cwe-id", "Unknown"),
                "url": item.get("matched-at", ""),
                "parameter": "",
                "description": item.get("info", {}).get("description", ""),
                "impact": item.get("info", {}).get("impact", ""),
                "remediation": item.get("info", {}).get("remediation", ""),
                "evidence": item.get("matcher-name", "") + ": " + str(item.get("matched-at", "")),
                "cvss_score": 0.0
            }
            
            # Extract CVSS score if available
            if "metadata" in item.get("info", {}) and "cvss-score" in item.get("info", {}).get("metadata", {}):
                vulnerability["cvss_score"] = float(item.get("info", {}).get("metadata", {}).get("cvss-score", 0.0))
            
            vulnerabilities.append(vulnerability)
        
        return {
            "vulnerabilities": vulnerabilities
        }
    
    def _get_zap_config_schema(self) -> Dict[str, Any]:
        """Get configuration schema for ZAP scanner"""
        return {
            "scan_policy": {
                "type": "string",
                "description": "ZAP scan policy to use",
                "enum": ["Default Policy", "API Scan", "Baseline Scan", "Full Scan"],
                "default": "Default Policy",
                "required": True
            },
            "ajax_spider": {
                "type": "boolean",
                "description": "Use AJAX Spider in addition to traditional spider",
                "default": True,
                "required": False
            },
            "api_key": {
                "type": "string",
                "description": "ZAP API key",
                "required": False
            },
            "context_name": {
                "type": "string",
                "description": "ZAP context name",
                "default": "Default Context",
                "required": False
            },
            "severity_filter": {
                "type": "string",
                "description": "Minimum severity to report",
                "enum": ["info", "low", "medium", "high", "critical"],
                "default": "low",
                "required": False
            }
        }
    
    def _parse_zap_results(self, raw_results: Any) -> Dict[str, Any]:
        """Parse ZAP scan results"""
        # In a real implementation, this would parse ZAP's JSON output
        # For this implementation, we'll assume raw_results is already a dict
        if isinstance(raw_results, str):
            try:
                results = json.loads(raw_results)
            except json.JSONDecodeError:
                # Handle non-JSON format
                return {
                    "vulnerabilities": [],
                    "error": "Unable to parse ZAP output as JSON"
                }
        else:
            results = raw_results
        
        # Convert to standard format
        vulnerabilities = []
        
        # ZAP uses different severity levels
        zap_severity_map = {
            0: "info",
            1: "low",
            2: "medium",
            3: "high"
        }
        
        for site in results.get("site", []):
            site_url = site.get("@name", "")
            
            for alert in site.get("alerts", []):
                for instance in alert.get("instances", []):
                    vulnerability = {
                        "id": f"zap-{alert.get('pluginId', 'unknown')}",
                        "type": alert.get("name", "Unknown"),
                        "severity": zap_severity_map.get(int(alert.get("riskcode", 0)), "info"),
                        "cwe": f"CWE-{alert.get('cweid', '0')}",
                        "url": instance.get("uri", site_url),
                        "parameter": instance.get("param", ""),
                        "description": alert.get("description", ""),
                        "impact": alert.get("riskdesc", ""),
                        "remediation": alert.get("solution", ""),
                        "evidence": instance.get("evidence", ""),
                        "cvss_score": 0.0
                    }
                    
                    vulnerabilities.append(vulnerability)
        
        return {
            "vulnerabilities": vulnerabilities
        }
    
    def _get_burpsuite_config_schema(self) -> Dict[str, Any]:
        """Get configuration schema for Burp Suite scanner"""
        return {
            "scan_type": {
                "type": "string",
                "description": "Type of scan to perform",
                "enum": ["crawl", "audit", "crawl_and_audit"],
                "default": "crawl_and_audit",
                "required": True
            },
            "scan_configuration": {
                "type": "string",
                "description": "Scan configuration to use",
                "enum": ["Lightweight", "Medium", "Full"],
                "default": "Medium",
                "required": False
            },
            "api_key": {
                "type": "string",
                "description": "Burp Suite Enterprise API key",
                "required": True
            },
            "severity_filter": {
                "type": "string",
                "description": "Minimum severity to report",
                "enum": ["info", "low", "medium", "high", "critical"],
                "default": "low",
                "required": False
            },
            "application_logins": {
                "type": "array",
                "description": "Application login credentials",
                "items": {
                    "type": "object"
                },
                "required": False
            }
        }
    
    def _parse_burpsuite_results(self, raw_results: Any) -> Dict[str, Any]:
        """Parse Burp Suite scan results"""
        # In a real implementation, this would parse Burp Suite's XML or JSON output
        # For this implementation, we'll assume raw_results is already a dict
        if isinstance(raw_results, str):
            try:
                if raw_results.startswith("<?xml"):
                    # Parse XML results (not implemented in this mock)
                    return {
                        "vulnerabilities": [],
                        "error": "XML parsing not implemented in this mock"
                    }
                else:
                    results = json.loads(raw_results)
            except (json.JSONDecodeError, ValueError):
                # Handle non-JSON format
                return {
                    "vulnerabilities": [],
                    "error": "Unable to parse Burp Suite output"
                }
        else:
            results = raw_results
        
        # Convert to standard format
        vulnerabilities = []
        
        # Burp Suite severity mapping
        burp_severity_map = {
            "information": "info",
            "low": "low",
            "medium": "medium",
            "high": "high"
        }
        
        for issue in results.get("issues", []):
            vulnerability = {
                "id": f"burp-{issue.get('serial_number', 'unknown')}",
                "type": issue.get("issue_type", "Unknown"),
                "severity": burp_severity_map.get(issue.get("severity", "").lower(), "info"),
                "cwe": "",  # Burp doesn't always provide CWE
                "url": issue.get("url", ""),
                "parameter": issue.get("request_parameter", ""),
                "description": issue.get("issue_detail", ""),
                "impact": issue.get("issue_background", ""),
                "remediation": issue.get("remedy_detail", ""),
                "evidence": issue.get("issue_detail", ""),
                "cvss_score": 0.0
            }
            
            vulnerabilities.append(vulnerability)
        
        return {
            "vulnerabilities": vulnerabilities
        }
    
    def _get_nmap_config_schema(self) -> Dict[str, Any]:
        """Get configuration schema for Nmap scanner"""
        return {
            "scan_type": {
                "type": "string",
                "description": "Type of scan to perform",
                "enum": ["quick", "regular", "full", "vuln"],
                "default": "regular",
                "required": True
            },
            "ports": {
                "type": "string",
                "description": "Ports to scan",
                "default": "1-1000",
                "required": False
            },
            "timing_template": {
                "type": "integer",
                "description": "Timing template (0-5)",
                "minimum": 0,
                "maximum": 5,
                "default": 3,
                "required": False
            },
            "scripts": {
                "type": "array",
                "description": "NSE scripts to run",
                "items": {
                    "type": "string"
                },
                "default": ["default", "vuln"],
                "required": False
            },
            "severity_filter": {
                "type": "string",
                "description": "Minimum severity to report",
                "enum": ["info", "low", "medium", "high", "critical"],
                "default": "low",
                "required": False
            }
        }
    
    def _parse_nmap_results(self, raw_results: Any) -> Dict[str, Any]:
        """Parse Nmap scan results"""
        # In a real implementation, this would parse Nmap's XML output
        # For this implementation, we'll assume raw_results is already a dict
        if isinstance(raw_results, str):
            try:
                if raw_results.startswith("<?xml"):
                    # Parse XML results (not implemented in this mock)
                    return {
                        "vulnerabilities": [],
                        "error": "XML parsing not implemented in this mock"
                    }
                else:
                    results = json.loads(raw_results)
            except (json.JSONDecodeError, ValueError):
                # Handle non-JSON format
                return {
                    "vulnerabilities": [],
                    "error": "Unable to parse Nmap output"
                }
        else:
            results = raw_results
        
        # Convert to standard format
        vulnerabilities = []
        
        # Process hosts
        for host in results.get("hosts", []):
            host_addr = host.get("address", {}).get("addr", "unknown")
            
            # Process ports
            for port in host.get("ports", []):
                port_id = port.get("portid", "0")
                service = port.get("service", {}).get("name", "unknown")
                
                # Process scripts (vulnerabilities)
                for script in port.get("scripts", []):
                    script_id = script.get("id", "unknown")
                    output = script.get("output", "")
                    
                    # Determine severity based on script ID
                    severity = "info"
                    if "vuln" in script_id:
                        # Extract severity from script output if possible
                        if "CRITICAL" in output.upper():
                            severity = "critical"
                        elif "HIGH" in output.upper():
                            severity = "high"
                        elif "MEDIUM" in output.upper():
                            severity = "medium"
                        elif "LOW" in output.upper():
                            severity = "low"
                        else:
                            severity = "medium"  # Default for vuln scripts
                    
                    vulnerability = {
                        "id": f"nmap-{script_id}",
                        "type": script_id,
                        "severity": severity,
                        "cwe": "",  # Nmap doesn't provide CWE
                        "url": f"{host_addr}:{port_id}",
                        "parameter": f"service: {service}",
                        "description": output,
                        "impact": "",
                        "remediation": "",
                        "evidence": output,
                        "cvss_score": 0.0
                    }
                    
                    # Extract CVSS if available
                    if "CVSS" in output:
                        cvss_match = re.search(r"CVSS:.*?([0-9]+\.[0-9]+)", output)
                        if cvss_match:
                            vulnerability["cvss_score"] = float(cvss_match.group(1))
                    
                    vulnerabilities.append(vulnerability)
        
        return {
            "vulnerabilities": vulnerabilities
        }
